[{"title":"gulp-ejs","date":"2017-05-10T02:17:58.000Z","path":"2017/05/10/gulp-ejs/","text":"一个经典且使用简单的js模板引擎。 &nbsp; 一、gulp-ejs安装1.项目下安装gulp-ejs1$ npm install gulp-ejs --save-dev 2.gulpfile.js文件中引入 1var ejs = require(&apos;gulp-ejs&apos;); ok，可以在项目中使用了 &nbsp; 二：gulp-ejs使用2.1 项目目录结构) 2.2 html文件如何引用ejs文件1234567891011&lt;%- include(&apos;../tpl/global/head&apos;) %&gt;&lt;body style=&quot;padding:0; margin:0 auto;background-color:#ebecee;&quot;&gt; &lt;div style=&quot;width:750px;margin:0 auto;&quot;&gt; &lt;%- include(&apos;../tpl/index/edmTpl&apos;) %&gt; &lt;%- include(&apos;../tpl/index/footer&apos;) %&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;&lt;/html&gt; 2.3 json数据模板定义123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&#123; &quot;header&quot;: &#123; &quot;borwserUrl&quot;: &quot;&quot;, &quot;logo&quot;: &#123; &quot;imgUrl&quot;: &quot;@resUrl/images/logo.png&quot;, &quot;linkUrl&quot;: &quot;http://nres.ingdan.com&quot; &#125;, &quot;title&quot;: &quot;本周硬三条&quot;, &quot;time&quot;: &quot;&quot; &#125;, &quot;edmTpls&quot;: [&#123; &quot;edmTpl&quot;: &#123; &quot;bannerUrl&quot;: &quot;@resUrl/images/banner_03.jpg&quot;, &quot;themes&quot;: [&quot;2步让你开发出“中国版 Echo”&quot;, &quot;云知声要做“中国版 Alexa”&quot;], &quot;contents&quot;: [&quot;云知声在AWE 2017上推出了 AIOS@Home的智能家居 AI 解决方案，&quot;, &quot;可以让用户和家庭设备实现全语音交互，并实现“智能互联”.&quot; ], &quot;btnUrl&quot;: &#123; &quot;imgUrl&quot;: &quot;@resUrl/images/btn.png&quot;, &quot;linkUrl&quot;: &quot;http://m.ingdan.com/toutiao/article/detail-317.html&quot; &#125; &#125; &#125;, &#123; &quot;edmTpl&quot;: &#123; &quot;bannerUrl&quot;: &quot;@resUrl/images/banner_02.jpg&quot;, &quot;themes&quot;: [&quot;黄锦锋：Sleepace靠什么拿到&quot;, &quot;4000多万融资&quot;], &quot;contents&quot;: [&quot;专家级核心技术、出色的产品定位、人性化的用户体验设计，&quot;, &quot;以及清晰的品牌合作布局，这些都是吸引投资方的重要因素。&quot;], &quot;btnUrl&quot;: &#123; &quot;imgUrl&quot;: &quot;@resUrl/images/btn.png&quot;, &quot;linkUrl&quot;: &quot;http://m.ingdan.com/toutiao/article/detail-319.html&quot; &#125; &#125; &#125;, &#123; &quot;edmTpl&quot;: &#123; &quot;bannerUrl&quot;: &quot;@resUrl/images/banner_04.jpg&quot;, &quot;themes&quot;: [&quot;硬蛋聚投100-投资人私享会&quot;], &quot;contents&quot;: [&quot;深度解析智能硬件投资中的供应链话题，通过实战案例分享、&quot;, &quot;圆桌问答等环节，深度分享硬件供应链的关键技术点，&quot;, &quot;破解硬件投资迷局。期待您的参与!&quot; ], &quot;btnUrl&quot;: &#123; &quot;imgUrl&quot;: &quot;@resUrl/images/btn.png&quot;, &quot;linkUrl&quot;: &quot;http://c.eqxiu.com/s/Es2mhESC&quot; &#125; &#125; &#125;, &#123; &quot;edmTpl&quot;: &#123; &quot;bannerUrl&quot;: &quot;@resUrl/images/banner_05.jpg&quot;, &quot;themes&quot;: [&quot;IN头条周报&quot;], &quot;contents&quot;: [&quot;一图读懂本周大事件&quot;], &quot;btnUrl&quot;: &#123; &quot;imgUrl&quot;: &quot;@resUrl/images/btn.png&quot;, &quot;linkUrl&quot;: &quot;http://m.ingdan.com/toutiao/article/detail-320.html&quot; &#125; &#125; &#125;]&#125; 2.4 ejs文件填充json数据我们来看edm的主体部分的ejs使用 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;% edmTpls.forEach(function(tpl)&#123; %&gt; &lt;table align=&quot;center&quot; cellpadding=&quot;0&quot; cellspacing=&quot;0&quot;&gt; &lt;tr&gt; &lt;td height=&quot;30&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;% var edmTpl = tpl.edmTpl %&gt; &lt;table style=&quot;width:750px;text-align: center;background-color:#fff;border-radius:10px;&quot; align=&quot;center&quot; cellpadding=&quot;0&quot; cellspacing=&quot;0&quot;&gt; &lt;tr&gt; &lt;td&gt;&lt;img src=&quot;&lt;%= edmTpl.bannerUrl %&gt;&quot; alt=&quot;&quot; style=&quot;width:750px;&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr height=&quot;40&quot;&gt; &lt;/tr&gt; &lt;% edmTpl.themes.forEach(function(theme)&#123; %&gt; &lt;tr&gt; &lt;td style=&quot;font-size:30px;font-family:&apos;微软雅黑&apos;,&apos;sans-serif&apos;;color:#26252d;&quot;&gt;&lt;%= theme %&gt; &lt;/td&gt; &lt;/tr&gt; &lt;% &#125;) %&gt; &lt;tr height=&quot;40&quot;&gt;&lt;/tr&gt; &lt;% edmTpl.contents.forEach(function(content)&#123; %&gt; &lt;tr height=&quot;35&quot;&gt; &lt;td style=&quot;font-size:18px;font-family:&apos;微软雅黑&apos;,&apos;sans-serif&apos;;color:#7e8188;&quot;&gt; &lt;%= content %&gt; &lt;/td&gt; &lt;/tr&gt; &lt;% &#125;) %&gt; &lt;tr height=&quot;40&quot;&gt;&lt;/tr&gt; &lt;tr&gt; &lt;td&gt; &lt;a target=&quot;_blank&quot; href=&quot;&lt;%= edmTpl.btnUrl.linkUrl %&gt;&quot;&gt;&lt;img src=&quot;&lt;%= edmTpl.btnUrl.imgUrl %&gt;&quot; alt=&quot;&quot;&gt;&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr height=&quot;40&quot;&gt;&lt;/tr&gt; &lt;/table&gt; &lt;% &#125;) %&gt; 2.5 gulp配置文件12345678910111213141516171819202122232425//替换json文件中的路径gulp.task(&apos;json&apos;, function(done) &#123; gulp.src(&quot;dev/**/*.json&quot;) .pipe(replace(/@resUrl/g, _releasedUrl)) .pipe(gulp.dest(&quot;res&quot;)) .on(&apos;end&apos;, done);&#125;);// 模版合并gulp.task(&apos;ejs&apos;, [&apos;json&apos;], function(done) &#123; gulp.src(&apos;dev/html/**/*.html&apos;) .pipe(data(function(file) &#123; var filePath = file.path; console.log(path.basename(filePath, &apos;.html&apos;) + &apos;.json&apos;); /*根据页面html文件的文件名寻找对应的json文件*/ return JSON.parse(fs.readFileSync(&apos;res/json/&apos; + path.basename(filePath, &apos;.html&apos;) + &apos;.json&apos;)); &#125;)) .pipe(ejs().on(&apos;error&apos;, function(err) &#123; gutil.log(err); this.emit(&apos;end&apos;); &#125;)) .pipe(gulp.dest(&quot;res/html&quot;)) .on(&apos;end&apos;, done);&#125;); 2.6 生成静态页面本地执行如下命令1gulp 生成的静态页面结构 三、引入公共的css和js文件3.1 在公共的global.json文件中配置123456789&#123; &quot;styles&quot;: [ &quot;//cdn.bootcss.com/bootstrap/3.3.5/css/bootstrap.min.css&quot; ], &quot;scripts&quot;: [ &quot;//cdn.bootcss.com/jquery/1.11.3/jquery.min.js&quot;, &quot;//cdn.bootcss.com/bootstrap/3.3.5/js/bootstrap.min.js&quot; ]&#125; 3.2 在公共的global/head.ejs文件中引入1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;title&gt;首页&lt;/title&gt;&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;&lt;meta name=&quot;renderer&quot; content=&quot;webkit&quot;&gt;&lt;% styles.forEach(function(sty)&#123; %&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;&lt;%= sty %&gt;&quot;&gt;&lt;% &#125;) %&gt;&lt;% if(local.styles) &#123; local.styles.forEach(function(sty)&#123; %&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;&lt;%= sty %&gt;&quot;&gt;&lt;% &#125;) &#125; %&gt;&lt;/head&gt; 最后生成的静态页面就会将公共的css和js文件引入进去，当然可以定义当前页面需要引入的css文件和js文件，代码同上","tags":[{"name":"nodejs","slug":"nodejs","permalink":"http://yoursite.com/tags/nodejs/"},{"name":"gulp","slug":"gulp","permalink":"http://yoursite.com/tags/gulp/"},{"name":"ejs","slug":"ejs","permalink":"http://yoursite.com/tags/ejs/"},{"name":"分享","slug":"分享","permalink":"http://yoursite.com/tags/分享/"}]},{"title":"vuejs基础入门","date":"2017-04-26T02:34:00.000Z","path":"2017/04/26/vuejs基础入门/","text":"为什么要学习vuejs？因为这两年vuejs蛮火的，而且易入门，实用。vuejs 是一套构建用户界面的 渐进式框架。vuejs 的目标是通过尽可能简单的 API 实现响应的数据绑定和组合的视图组件。vuejs 现在不支持IE8及以下，以后也不会支持。 一、基本语法1、插值1.1 文本双大括号包裹住变量名1&lt;div id=\"app\"&gt;&#123;&#123; message &#125;&#125;&lt;/div&gt; 1.2 纯HTML使用v-html指令输出html1&lt;div v-html=\"message\"&gt;&lt;/div&gt; 1.3 属性使用v-bind指令绑定dom元素属性1&lt;div v-bind:id=\"message\" v-bind:data-abc=\"message\"&gt;&lt;/div&gt; 1.4 JavaScript 表达式使用双大括号包裹住表达式1234&lt;p&gt;&#123;&#123; number + 1 &#125;&#125;&lt;/p&gt;&lt;p&gt;&#123;&#123; ok ? 'YES' : 'NO' &#125;&#125;&lt;/p&gt;&lt;p&gt;&#123;&#123; message.split('').reverse().join('') &#125;&#125;&lt;/p&gt;&lt;p v-bind:id=\"'list-' + id\"&gt;&lt;/p&gt; 这些表达式会在所属 Vue 实例的数据作用域下作为 JavaScript 被解析。有个限制就是，每个绑定都只能包含单个表达式，所以下面的例子都不会生效。类似于一个function，执行一系列语句后，必须 return 一个结果。 1234&lt;!-- 这是语句，不是表达式 --&gt;&#123;&#123; var a = 1 &#125;&#125;&lt;!-- 流控制也不会生效，请使用三元表达式 --&gt;&#123;&#123; if (ok) &#123; return message &#125; &#125;&#125; 不应该在模板表达式中试图访问用户定义的全局变量 2、指令指令（Directives）是带有 v- 前缀的特殊属性 2.1 参数如下：url和doSomething就是传入vue实例的参数，url是一个变量，doSomething是一个方法名12&lt;a v-bind:href=\"url\"&gt;&lt;/a&gt;&lt;a v-on:click=\"doSomething\"&gt; 2.2 修饰符修饰符（Modifiers）是以半角句号 . 指明的特殊后缀，用于指出一个指令应该以特殊方式绑定.prevent修饰符告诉v-on指令对于触发的事件调用event.preventDefault()来阻止默认行为1&lt;form v-on:submit.prevent=\"onSubmit\"&gt;&lt;/form&gt; 事件修饰符有：.stop``.prevent``.capture``.self``.once更多修饰符自己查.. 3、过滤器vuejs 允许你自定义过滤器，可被用作一些常见的文本格式化。过滤器可以用在两个地方：插值和v-bind表达式。过滤器应该被添加在 JavaScript 表达式的尾部，由“管道”符指示 1234&lt;!-- in 插值 --&gt;&#123;&#123; message | capitalize &#125;&#125;&lt;!-- in v-bind --&gt;&lt;div v-bind:id=\"rawId | formatId\"&gt;&lt;/div&gt; 123456789101112new Vue(&#123; // ... filters: &#123; // 自定义过滤器 // 过滤器函数总接受表达式的值作为第一个参数 capitalize: function (value) &#123; if (!value) return '' value = value.toString() return value.charAt(0).toUpperCase() + value.slice(1) &#125; &#125;&#125;) 过滤器可以串联12&lt;!-- 多个过滤器 --&gt;&#123;&#123; message | filterA | filterB &#125;&#125; 过滤器可以接受参数1&#123;&#123; message | filterA('arg1', arg2) &#125;&#125; 字符串&#39;arg1&#39;将传给过滤器作为第二个参数，arg2表达式的值将被求值然后传给过滤器作为第三个参数 4、缩写v-前缀在模板中是作为一个标示 Vue 特殊属性的明显标识，整个应用都使用vuejs的话，那么前缀v-就没有那么重要123456789&lt;!-- v-bind 完整语法 --&gt;&lt;a v-bind:href=\"url\"&gt;&lt;/a&gt;&lt;!-- v-bind 缩写 --&gt;&lt;a :href=\"url\"&gt;&lt;/a&gt;&lt;!-- v-on 完整语法 --&gt;&lt;a v-on:click=\"doSomething\"&gt;&lt;/a&gt;&lt;!-- v-on 缩写 --&gt;&lt;a @click=\"doSomething\"&gt;&lt;/a&gt; 实际是，不用缩写也是挺好的。 二、基本用法在学习之前，先把vuejs下载下来放在本地，直接使用script标签引入即可。 1、声明式渲染1&lt;div id=\"app\"&gt;&#123;&#123; message &#125;&#125;&lt;/div&gt; 123456var app = new Vue(&#123; el: '#app', data: &#123; message: '你好，程序猿！' &#125;&#125;) 结果输出：你好，程序猿！ 2、绑定 DOM 元素属性123&lt;div id=\"app-2\"&gt; &lt;span v-bind:title=\"message\" v-bind:data-alt=\"message\"&gt;鼠标移动到我上边来&lt;/span&gt;&lt;/div&gt; 123456var app2 = new Vue(&#123; el: '#app-2', data: &#123; message: '什么都没有' &#125;&#125;) 生成HTML：1&lt;div id=\"app-2\"&gt;&lt;span title=\"什么都没有\" data-alt=\"什么都没有\"&gt;鼠标移动到我上边来&lt;/span&gt;&lt;/div&gt; 3、if语句1234&lt;div id=\"app-3\"&gt; &lt;p v-if=\"seen\"&gt;看得见我&lt;/p&gt; &lt;p v-if=\"!seen\"&gt;看不见我&lt;/p&gt;&lt;/div&gt; 123456var app3 = new Vue(&#123; el: '#app-3', data: &#123; seen: true &#125;&#125;) 在命令行改变app3.seen的值，会看到页面内容的变化 4、for循环1234567&lt;div id=\"app-4\"&gt; &lt;ol&gt; &lt;li v-for=\"item in todos\"&gt; &#123;&#123; item.text &#125;&#125; &lt;/li&gt; &lt;/ol&gt;&lt;/div&gt; 12345678910var app4 = new Vue(&#123; el: '#app-4', data: &#123; todos: [ &#123; text: '不要学 JavaScript' &#125;, &#123; text: '不要学 Vue' &#125;, &#123; text: '什么都不要学' &#125; ] &#125;&#125;) 生成HTML：12345&lt;ol&gt; &lt;li&gt;不要学 JavaScript&lt;/li&gt; &lt;li&gt;不要学 Vue&lt;/li&gt; &lt;li&gt;什么都不要学&lt;/li&gt;&lt;/ol&gt; 5、v-on监听事件1234&lt;div id=\"app-5\"&gt; &lt;p&gt;&#123;&#123; message &#125;&#125;&lt;/p&gt; &lt;button v-on:click=\"toChange\"&gt;点我点我点我&lt;/button&gt;&lt;/div&gt; 1234567891011var app5 = new Vue(&#123; el: '#app-5', data: &#123; message: '我是一串很长的字符串' &#125;, methods: &#123; toChange: function () &#123; this.message = this.message.split('').reverse().join(''); &#125; &#125;&#125;) 点击按钮，文字会经过toChange方法处理，进行逆序并输出 6、v-model指令在表单输入和应用状态中做双向数据绑定 1234&lt;div id=\"app-6\"&gt; &lt;p&gt;&#123;&#123; message &#125;&#125;&lt;/p&gt; &lt;input v-model=\"message\"&gt;&lt;/div&gt; 123456var app6 = new Vue(&#123; el: '#app-6', data: &#123; message: '写点什么好呢' &#125;&#125;) 改变输入框的值，或者在控制台改变app6.message的值，页面中的文本及输入框的值都会同时改变 三、组件将vuejs应用到开发中，组件是必不可少的部分。 1234567&lt;div id=\"app-7\"&gt; &lt;ol&gt; &lt;todo-item v-for=\"item in list\" v-bind:ccc=\"item\"&gt;&lt;/todo-item&gt; &lt;li v-for=\"item in list\"&gt;2&#123;&#123; item.text &#125;&#125;&lt;/li&gt; &lt;/ol&gt;&lt;/div&gt; 上段代码中，ccc相当于function中接收到的形参，作用于function内部1234567891011121314151617// 定义组件Vue.component('todo-item', &#123; props: ['ccc'], template: '&lt;li&gt;&#123;&#123; ccc.text &#125;&#125;&lt;/li&gt;'&#125;)// vue实例var app7 = new Vue(&#123; el: '#app-7', data: &#123; list: [ &#123; text: '不要学 JavaScript' &#125;, &#123; text: '不要学 Vue' &#125;, &#123; text: '什么都不要学' &#125; ] &#125;&#125;) 以上代码执行后发现，使用组件输出与直接用for循环输出，结果是一致的，但使用组件有更多的可控性 四、总结不需要关注页面dom的操作，只需要管理页面数据即可！","tags":[{"name":"vuejs","slug":"vuejs","permalink":"http://yoursite.com/tags/vuejs/"}]},{"title":"flexbox布局","date":"2017-04-25T07:55:55.000Z","path":"2017/04/25/2017-4-25-flexbox布局/","text":"布局的传统解决方案，基于盒状模型，依赖 display属性 + position属性 + float属性。它对于那些特殊布局非常不方便，比如，垂直居中就不容易实现。2009年，W3C提出了一种新的方案—-Flex布局，可以简便、完整、响应式地实现各种页面布局。目前，它已经得到了所有浏览器的支持，这意味着，现在就能很安全地使用这项功能。 &nbsp; 1、基本概念Flex是Flexible Box的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性。采用Flex布局的元素，称为Flex容器（flex container），简称”容器“。它的所有子元素自动成为容器成员，称为Flex项目（flex item），简称”项目。注意，设为Flex布局以后，子元素的float、clear和vertical-align属性将失效。 容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。主轴的开始位置（与边框的交叉点）叫做main start，结束位置叫做main end；交叉轴的开始位置叫做cross start，结束位置叫做cross end。项目默认沿主轴排列。单个项目占据的主轴空间叫做main size，占据的交叉轴空间叫做cross size。 2、容器的属性2.1 flex-directionflex-direction属性决定主轴的方向（即项目的排列方向）, 有以下取值： row（默认值）：主轴为水平方向，起点在左端。 row-reverse：主轴为水平方向，起点在右端。 column：主轴为垂直方向，起点在上沿。 column-reverse：主轴为垂直方向，起点在下沿。2.2 flex-wrap默认情况下，项目都排在一条线（又称”轴线”）上。flex-wrap属性定义，如果一条轴线排不下，如何换行,有以下取值： nowrap（默认）：不换行 wrap：换行，第一行在上方。 wrap-reverse：换行，第一行在下方2.3 flex-flowflex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap。2.4 justify-contentjustify-content属性定义了项目在主轴上的对齐方式。 flex-start（默认值）：左对齐 flex-end：右对齐 center： 居中 space-between：两端对齐，项目之间的间隔都相等。 space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。2.5 align-itemsalign-items属性定义项目在交叉轴上如何对齐。 flex-start：交叉轴的起点对齐。 flex-end：交叉轴的终点对齐。 center：交叉轴的中点对齐。 baseline: 项目的第一行文字的基线对齐。 stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。2.6 align-contentalign-content属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。 flex-start：与交叉轴的起点对齐。 flex-end：与交叉轴的终点对齐。 center：与交叉轴的中点对齐。 space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。 space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。 stretch（默认值）：轴线占满整个交叉轴。 3、项目的属性3.1 orderorder属性定义项目的排列顺序。数值越小，排列越靠前，默认为0 3.2 flex-growflex-grow属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。如果所有项目的flex-grow属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。 3.3 flex-shrinkflex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小。 3.4 flex-basisflex-basis属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。它可以设为跟width或height属性一样的值（比如350px），则项目将占据固定空间。 3.5 flexflex属性是flex-grow, flex-shrink 和flex-basis的简写，默认值为0 1 auto。后两个属性可选。建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值 3.6 align-selfalign-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。该属性可能取6个值，除了auto，其他都与align-items属性完全一致。 4、布局实战公共样式 12345678910111213141516.box&#123; display: flex; width: 250px; height: 250px; border-radius: 15px; background-color: #f5f5d5;&#125;.item&#123; width: 60px; height: 60px; border-radius: 50%; color: #fff; background-color: black; text-align: center;&#125; 实例1: 12345&lt;div class=&quot;box eg1&quot;&gt; &lt;span class=&quot;item&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;item&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;item&quot;&gt;3&lt;/span&gt;&lt;/div&gt; 12345.eg1&#123; flex-direction: row-reverse; align-items: center; justify-content: center;&#125; &nbsp; 实例2: 12345678&lt;div class=&quot;box eg2&quot;&gt; &lt;span class=&quot;item&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;item&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;item&quot;&gt;3&lt;/span&gt; &lt;span class=&quot;item&quot;&gt;4&lt;/span&gt; &lt;span class=&quot;item&quot;&gt;5&lt;/span&gt; &lt;span class=&quot;item&quot;&gt;6&lt;/span&gt;&lt;/div&gt; 1234.eg2&#123; flex-wrap: wrap; align-content: space-around;&#125; &nbsp; 实例3: 1234567891011121314&lt;div class=&quot;box eg3&quot;&gt; &lt;div class=&quot;row&quot;&gt; &lt;span class=&quot;item&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;item&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;item&quot;&gt;3&lt;/span&gt; &lt;/div&gt; &lt;div class=&quot;row&quot;&gt; &lt;span class=&quot;item&quot;&gt;3&lt;/span&gt; &lt;/div&gt; &lt;div class=&quot;row&quot;&gt; &lt;span class=&quot;item&quot;&gt;4&lt;/span&gt; &lt;span class=&quot;item&quot;&gt;5&lt;/span&gt; &lt;/div&gt;&lt;/div&gt; 12345678910111213141516.eg3&#123; flex-wrap: wrap;&#125;.eg3 .row&#123; display: flex; flex-basis:100%;&#125;.eg3 .row:nth-child(2)&#123; justify-content: center;&#125;.eg3 .row:nth-child(3)&#123; justify-content: space-between;&#125; &nbsp; 实例4: 1234567891011&lt;div class=&quot;box eg4&quot;&gt; &lt;span class=&quot;item&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;item&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;item&quot;&gt;3&lt;/span&gt; &lt;span class=&quot;item&quot;&gt;4&lt;/span&gt; &lt;span class=&quot;item&quot;&gt;5&lt;/span&gt; &lt;span class=&quot;item&quot;&gt;6&lt;/span&gt; &lt;span class=&quot;item&quot;&gt;7&lt;/span&gt; &lt;span class=&quot;item&quot;&gt;8&lt;/span&gt; &lt;span class=&quot;item&quot;&gt;9&lt;/span&gt;&lt;/div&gt; 123456789.eg4&#123; flex-wrap: wrap; justify-content: space-between;&#125;.eg4 .item&#123; width: 63px; height: 63px;&#125; &nbsp; 实例5: 网格布局 1234567891011121314151617&lt;div class=&quot;Grid&quot;&gt; &lt;div class=&quot;Grid-cell&quot;&gt; &lt;span class=&quot;Grid-cell-item&quot;&gt;1/2&lt;/span&gt; &lt;span class=&quot;Grid-cell-item&quot;&gt;1/2&lt;/span&gt; &lt;/div&gt; &lt;div class=&quot;Grid-cell&quot;&gt; &lt;span class=&quot;Grid-cell-item&quot;&gt;1/3&lt;/span&gt; &lt;span class=&quot;Grid-cell-item&quot;&gt;1/3&lt;/span&gt; &lt;span class=&quot;Grid-cell-item&quot;&gt;1/3&lt;/span&gt; &lt;/div&gt; &lt;div class=&quot;Grid-cell&quot;&gt; &lt;span class=&quot;Grid-cell-item&quot;&gt;1/4&lt;/span&gt; &lt;span class=&quot;Grid-cell-item&quot;&gt;1/4&lt;/span&gt; &lt;span class=&quot;Grid-cell-item&quot;&gt;1/4&lt;/span&gt; &lt;span class=&quot;Grid-cell-item&quot;&gt;1/4&lt;/span&gt; &lt;/div&gt;&lt;/div&gt; 12345678910.Grid .Grid-cell&#123; display: flex;&#125;.Grid .Grid-cell .Grid-cell-item&#123; flex:1; margin:10px; text-align: center; background-color: #f3f3f3;&#125; &nbsp; 实例6：圣杯布局 123456789&lt;section class=&quot;body HolyGrail&quot;&gt; &lt;header&gt;i am header&lt;/header&gt; &lt;div class=&quot;HolyGrail-body&quot;&gt; &lt;main class=&quot;HolyGrail-content&quot;&gt;content&lt;/main&gt; &lt;nav class=&quot;HolyGrail-nav&quot;&gt;nav&lt;/nav&gt; &lt;aside class=&quot;HolyGrail-ads&quot;&gt;ads&lt;/aside&gt; &lt;/div&gt; &lt;footer&gt;i am footer&lt;/footer&gt;&lt;/section&gt; 1234567891011121314151617181920212223242526272829303132.HolyGrail&#123; display: flex; min-height: 500px; flex-direction: column; text-align: center; color: #fff;&#125;.HolyGrail header,.HolyGrail footer&#123; height: 65px; background-color: #666; &#125;.HolyGrail-body&#123; flex: 1; display: flex;&#125;.HolyGrail-ads&#123; width: 100px; background-color: #FF6633; &#125;.HolyGrail-content&#123; flex: 1; background-color: #D6D6D6; &#125;.HolyGrail-nav&#123; width: 80px; order: -1; background-color: #77BBDD; &#125;","tags":[{"name":"flexbox","slug":"flexbox","permalink":"http://yoursite.com/tags/flexbox/"},{"name":"css","slug":"css","permalink":"http://yoursite.com/tags/css/"},{"name":"页面布局","slug":"页面布局","permalink":"http://yoursite.com/tags/页面布局/"}]},{"title":"h5唤醒App","date":"2017-04-13T05:37:37.000Z","path":"2017/04/13/h5唤醒App/","text":"首先要声明的一点是，h5页面无法获取app的状态，也就是说，无法判断app是否已下载，app是否已打开。那么基于这个，怎么样实现在h5页面唤醒指定的app呢？请看下回分解~ 一般来讲，app产品都会有一个下载落地页，引导用户前往应用市场下载app应用，安卓的前往安卓市场，ios的跑到appstore。那么先不考虑页面的样式，首先进入到页面，第一步是获取设备信息，也就是浏览器信息。 1、获取设备信息12345678910111213141516171819202122function getPlatform()&#123; var u = navigator.userAgent, app = navigator.appVersion, iosVer = app.match(/OS (\\d+)_(\\d+)_?(\\d+)?/); return &#123; // android终端或者uc浏览器 android: u.indexOf('Android') &gt; -1 || u.indexOf('Linux') &gt; -1, // 是否为iPhone或者QQHD浏览器 iPhone: u.indexOf('iPhone') &gt; -1, // 是否iPad iPad: u.indexOf('iPad') &gt; -1, // ios 版本号 iosVer: iosVer &amp;&amp; parseInt(iosVer[1], 10), // 微信 weChat: u.indexOf('MicroMessenger') &gt; -1, // QQ QQ: u.indexOf('QQ') &gt; -1, // 微博 WeiBo: u.indexOf('weibo') &gt; -1 &#125;;&#125; 2、设置app下载地址安卓应用市场及appstore下载地址各不相同，所以要跟app的童鞋拿到应用下载地址123// 下载链接var _androidUrl = 'http://a.app.qq.com/o/simple.jsp?pkgname=com.ingdan.ingdannews';var _iosUrl = 'https://itunes.apple.com/us/app/in-tou-tiao-zhuan-zhu-zhi/id1197794545?l=zh&amp;ls=1&amp;mt=8'; 3、跳转app下载页面那么页面打开后，就应该判断设备，然后进行页面跳转了1234567891011var _platform = getPlatform();var _downloadUrl = _androidUrl;if(_platform.android)&#123; // 安卓&#125;else&#123; // ios _downloadUrl = _iosUrl;&#125;window.location.href = _downloadUrl; 是不是很完美了，当然不是，app还没打开呢，而且在各个不同环境有不同限制，例如在微信或微博中打开，是不允许直接跳转到appstore，那怎么解决？12345678if(_platform.android)&#123; // 安卓&#125;else&#123; // ios if(_platform.weChat || _platform.WeiBo)&#123; alert('请再浏览器中打开本页面~速去'); &#125;&#125; 看起来十分完美，然而还是没有，app也还没打开呢 4、打开APP如何打开app呢，这里需要注意的一点事，打开app必须要开发的童靴提供一个自定义协议，例如： 1var _appUrl = 'INNewsApp://'; 其中INNewsApp://是app开发自行决定的协议，当然最好后边能跟上app相对应的域名，如：INNewsApp://m.ingdan.com如果需要打开app后跳转到指定页面，那么就应该在链接中加入参数，如：INNewsApp://m.ingdan.com?id=9527 打来app地址有了，接下来如何处理？我们这里使用iframe来打开，避免了一旦url有误，或者手机上没有安装app导致报错。 1234567// 在iframe 中打开APPvar ifr = document.createElement('iframe');ifr.style.display = 'none';ifr.src = _appUrl;document.body.appendChild(ifr); 到了这时，在测试ios的时候发现一个问题，ios9以上，不支持iframe打开app于是乎1234567// 判断ios版本，ios9以上直接打开if(_platform.iosVer &gt;= 9)&#123; window.location.href = _appUrl;&#125;else&#123; // 在iframe 中打开APP // ...&#125; 如果手机上安装有app，这是h5就可以唤醒app，app就启动了。 5、一些兼容处理产品这时希望，那么如果手机上没有安装app，怎跳转到app下载页面，怎么办？先把产品打一顿再说 1234567setTimeout(function() &#123; // 2秒之后，移除iframe document.body.removeChild(ifr); // 跳转到app下载地址 window.location.href = _downloadUrl;&#125;, 2000); 这样似乎已经完美了，然后还没有。一般情况下，浏览器处于非激活状态、使用alert弹出信息或者系统信息提示，页面是会中断js运行的然后在QQ安卓版的内置浏览器上，并没有，更为让人开心的是，如果你的app是跳转到应用宝上，应用宝会自动判断你是否一下子该app，并且还很友好的帮你打开这个时候你就会发现，在QQ内置浏览器打开下载引导页面，app打开了，正看得高兴，过了2秒，app又打开一次… 于是乎1234// 非QQ内置浏览器if(!_platform.QQ)&#123; window.location.href = _downloadUrl;&#125; 那在QQ安卓版的内置浏览器上，如果有app，则自动打开，如果没有，怎么引导用户下载？页面上那么大一颗下载按钮，自己点吧。","tags":[]},{"title":"web workers","date":"2017-04-12T11:26:19.000Z","path":"2017/04/12/workers/","text":"javascript执行时，只有一条线程，也就是从上至下的去执行。如果某些脚本比较复杂、耗时，那么将会阻塞javascript继续执行，甚至导致浏览器失去响应。那么要实现javascript的多线程，可以使用定时器来实现。除了定时器，如今还可以使用woker来实现多线程处理。未完待续…","tags":[{"name":"html5","slug":"html5","permalink":"http://yoursite.com/tags/html5/"},{"name":"workers","slug":"workers","permalink":"http://yoursite.com/tags/workers/"},{"name":"web api","slug":"web-api","permalink":"http://yoursite.com/tags/web-api/"}]},{"title":"立即显示上传的图片(无需上传到服务器)","date":"2017-04-06T06:11:33.000Z","path":"2017/04/06/立即显示上传的图片/","text":"一、简介 很多时候我们上传图片都是要等待后端响应之后才获取图片数据去显示到也没上，但是有时候响应很慢，我有希望能够无需等待后端响应就显示上传的缩略图，那怎么做呢？ 二、实现方法可以直接查看下面的代码，使用jquery来实现的 1234567891011121314$(function() &#123; /*原理是把本地图片路径：\"D(盘符):/image/...\"转为\"http://...\"格式路径来进行显示图片*/ $(\"#fileupload\").change(function() &#123; var $file = $(this); var objUrl = $file[0].files[0]; //获得一个http格式的url路径:mozilla(firefox)||webkit or chrome var windowURL = window.URL || window.webkitURL; //createObjectURL创建一个指向该参数对象(图片)的URL var dataURL; dataURL = windowURL.createObjectURL(objUrl); $(\"#imageview\").attr(\"src\",dataURL); &#125;); &#125;); 页面代码1234&lt;body&gt; &lt;input id=\"fileupload\" type=\"file\" /&gt; &lt;img id=\"imageview\" &gt; &lt;/body&gt;","tags":[{"name":"img","slug":"img","permalink":"http://yoursite.com/tags/img/"},{"name":"upload","slug":"upload","permalink":"http://yoursite.com/tags/upload/"},{"name":"file","slug":"file","permalink":"http://yoursite.com/tags/file/"}]},{"title":"JavaScript排序算法及性能比较","date":"2017-03-30T02:23:43.000Z","path":"2017/03/30/JavaScript排序算法及性能比较/","text":"作者原文：http://www.boatsky.com/blog/10.html 说到算法，对很多同学来说，启蒙算法应该就是冒泡排序，我们也会见到它解决排序问题，然后，数据量稍大时，它就显的无力了。前端可能用到算法的机会不算多，但用到时又不会，临时去学，就有些痛苦了。 算法很大程度是数学问题，而算法的作者们往往是一些科学家或大牛，这确实需要良好的数学功底。但不要被它吓到，站在巨人的肩膀上，花些时间理解已有理论，就可以直接或间接使用现成算法解决问题，人类的智慧成长不正是代代智慧的叠加么？所以私以为学习算法，并不需要多好的数学素养。 前言 说到算法，对很多同学来说，启蒙算法应该就是冒泡排序，我们也会见到它解决排序问题，然后，数据量稍大时，它就显的无力了。前端可能用到算法的机会不算多，但用到时又不会，临时去学，就有些痛苦了。 算法很大程度是数学问题，而算法的作者们往往是一些科学家或大牛，这确实需要良好的数学功底。但不要被它吓到，站在巨人的肩膀上，花些时间理解已有理论，就可以直接或间接使用现成算法解决问题，人类的智慧成长不正是代代智慧的叠加么？所以私以为学习算法，并不需要多好的数学素养。 算法一般都是C/C++或者伪代码讲解，本文则使用JavaScript翻译一遍，大前端时代嘛。本文参考了《数据结构与算法JavaScript描述》。 1.冒泡排序冒泡排序是最简单的排序算法，效率也是最低的，它把相邻元素两两对比，比较n轮，每轮len-n次，以下都以数组5,1,7,0,9,2,3,8,4,6从小到大排序为例5,1,7,0,9,2,3,8,4,61,5,7,0,9,2,3,8,4,6 1轮,1次，比较5,1的结果1,5,7,0,9,2,3,8,4,6 1轮,2次，比较5,7的结果1,5,0,7,9,2,3,8,4,6 1轮,3次，比较7,0的结果1,5,0,7,9,2,3,8,4,6 1轮,4次，比较7,9的结果……1,5,0,7,2,3,8,4,9,6 1轮,8次，比较9,4的结果1,5,0,7,2,3,8,4,6,9 1轮,9次，比较9,6的结果第1轮完成，把最大值9移至最后，第2轮开始，我们只需比较8次 1,5,0,7,2,3,8,4,6,9 2轮,1次，比较1,51,0,5,7,2,3,8,4,6,9 2轮,2次，比较5,01,0,5,7,2,3,8,4,6,9 2轮,3次，比较5,71,0,5,2,7,3,8,4,6,9 2轮,4次，比较7,2……重复以上操作，第2轮则把8移至第8位，同理经过n(n+1)/2次比较后，得到最终结果。代码如下：1234567891011121314151617//冒泡排序function bubbleSort(arr)&#123; if(arr.length &gt; 1)&#123; var len = arr.length; var i,j,temp; for(i = 0;i &lt; len;i++)&#123; for(j = 0;j &lt; len - i;j++)&#123; if(arr[j] &gt; arr[j+1])&#123; temp = arr[j]; arr[j] = arr[j+1]; arr[j+1] = temp; &#125; &#125; &#125; &#125; return arr;&#125; 2.选择排序选择排序与冒泡排序有点相似之次，就是都需要比较n(n+1)/2次，不过它是把最小的数字，排在最前面，第2小的数字，排在第2位，虽然比较次数与冒泡排序一样，但数据交换次却常常比冒泡排序少很多，所以它的效率比冒泡排序更高一点。演示：5,1,7,0,9,2,3,8,4,61,5,7,0,9,2,3,8,4,6 1轮,1次，比较5,11,5,7,0,9,2,3,8,4,6 1轮,2次，比较1,70,5,7,1,9,2,3,8,4,6 1轮,3次，比较1,0……0,5,7,1,9,2,3,8,4,6 1轮,9次，比较0,6第1轮结束，注意了，第一轮第3次之后虽然会一直比较下去，直到0与6比较，但是0已经是最小的数字了，所以之后比较，都无需进行数据交换，提高了效率，但这是不稳定的。 0,5,7,1,9,2,3,8,4,6 2轮,1次，比较5,70,1,7,5,9,2,3,8,4,6 2轮,2次，比较5,1……0,1,7,5,9,2,3,8,4,6 2轮,8次，比较1,6重复n-1轮，得出最终结果。 1234567891011121314151617//选择排序function selectSort(arr)&#123; if(arr.length &gt; 1)&#123; var len = arr.length; var i,j,temp; for(i = 0;i &lt; len;i++)&#123; for(j = i+1;j &lt; len;j++)&#123; if(arr[i] &gt; arr[j])&#123; temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; &#125; &#125; &#125; &#125; return arr;&#125; 3.插入排序插入排序，是把数据一个插入已排序的数组中，只需插入n-1遍。5,1,7,0,9,2,3,8,4,61,5,7,0,9,2,3,8,4,6 1插入[5]中结果1,5,7,0,9,2,3,8,4,6 7插入[1,5]中结果0,1,5,7,9,2,3,8,4,6 0插入[1,5,7]中结果0,1,5,7,9,2,3,8,4,6 9插入[0,1,5,7]中结果……0,1,2,3,4,5,7,8,9,6 4插入[0,1,2,3,5,7,8,9,6]中结果0,1,2,3,4,5,6,7,8,9 6插入[0,1,2,3,4,5,6,7,8,9]中结果一共比较n(n+1)/2次，最坏的情况也需要交换这么多次数据，最好的情况，一次数据交换也不需要，所以它是不稳定的，但一般比选择排序快上一些。 代码如下：12345678910111213141516function insertSort(arr)&#123; if(arr.length &gt; 1)&#123; var len = arr.length; var i,j,temp; for(i = 1;i &lt; len;i++)&#123; temp = arr[i]; j = i; while(j &gt; 0 &amp;&amp; arr[j-1] &gt; temp)&#123; arr[j] = arr[j-1]; j--; &#125; arr[j] = temp; &#125; &#125; return arr;&#125; 4.归并排序归并排序，则是把已经排好序的子数组合并成一个大的数组。5,1,7,0,9,2,3,8,4,65, 1, 7, 0, 9, 2, 3, 8, 4, 6step 11,5, 0,7, 2,9, 3,8 4,6step 20,1,5,7, 2,3,8,9, 4,6step 40,1,2,3,5,7,8,9, 4,6 最终0,1,2,3,4,5,6,7,8,9 归并排序相对稳定，并且占用内存少，效率一般也比插入排序高。如数据量巨大，不方便使用太占内存的算法时，归并排序是你的选择！代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748function mergeSort(arr)&#123; if (arr.length &lt; 2)&#123; return arr; &#125; var step = 1; var left, right; while(step &lt; arr.length)&#123; left = 0; right = step; while(right + step &lt;= arr.length)&#123; mergeArrays(arr, left, left+step, right, right+step); left = right + step; right = left + step; &#125; if (right &lt; arr.length)&#123; mergeArrays(arr, left, left+step, right, arr.length); &#125; step *= 2; &#125; return arr;&#125;function mergeArrays(arr, startLeft, stopLeft, startRight, stopRight)&#123; var leftArr = new Array(stopLeft - startLeft + 1); var rightArr = new Array(stopRight - startRight + 1); var k = startLeft; for(var i = 0;i &lt; (leftArr.length-1);i++)&#123; leftArr[i] = arr[k]; k++; &#125; k = startRight; for(var i = 0;i &lt; (rightArr.length-1);i++)&#123; rightArr[i] = arr[k]; k++; &#125; rightArr[rightArr.length-1] = Infinity; leftArr[leftArr.length-1] = Infinity; var m = 0,n = 0; for(k = startLeft;k &lt; stopRight;k++)&#123; if (leftArr[m] &lt;= rightArr[n])&#123; arr[k] = leftArr[m]; m++; &#125; else &#123; arr[k] = rightArr[n]; n++; &#125; &#125;&#125; 5.希尔排序希尔排序，又是插入排序的改良版，即分组插入。5,1,7,0,9,2,3,8,4,6g为5时，分成5组5与2比较，1与3比较，7与8比较，0与4比较，9与6比较2,1,7,0,6,5,3,8,4,9g为2时，分成2组2,7,6,3,4与1,0,5,8,9，分别进行插入排序得到2,3,4,6,7与0,1,5,8,9结果为2,0,3,1,4,5,6,8,9,9g为1时，进行插入排序得到0,1,2,3,4,5,6,8,9,7,8其并不稳定，但因为使用间隔比较，减少了交换次数，在多数情况，比归并更快一点点。代码如下：12345678910111213141516171819202122232425//希尔排序function shellSort(arr)&#123; if(arr.length &gt; 1)&#123; var len = arr.length; var g,i,j, k,temp; //第几轮分组 for(g = Math.floor(len / 2);g &gt; 0;g = Math.floor(g / 2))&#123; for(i = 0;i &lt; g;i++)&#123; for(j = i + g;j &lt; len;j = j + g)&#123; if(arr[j - g] &gt; arr[j])&#123; temp = arr[j]; k = j - g; while(k &gt;= 0 &amp;&amp; arr[k] &gt; temp)&#123; arr[k + g] = arr[k]; k = k - g; &#125; arr[k + g] = temp; &#125; &#125; &#125; &#125; &#125; return arr;&#125; 6.快速排序快速排序即排序很快速！那为什么它这么快？官方的描述是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。我们用实例来演示一下：5,1,7,0,9,2,3,8,4,6选中第0个元素即5作为中间值(不是大小的中间值，只是确定一个固定比较对象)，比5小的放在左数组，比5大的放在右数组，则变成[1,0,2,3,4]+5+[7,9,8,6]与此同时(不是第二步，整个过程都是在1步完成的)，选中左、右数组的第1个元素作为中间值。(ps: 为了好看，我把中间写成是一个数字，其实它是一个单元素数组)[0] + 1 + [2,3,4] + 5 + [6] + 7 + [9,8]与此同时再分解[0] + 1 + 2 + [3,4] + 5 + [6] + 7 + 9 + [8]同时[0] + 1 + 2 + 3 + [4] + 5 + [6] + 7 + 9 + [8]快的原因就是它使用空间换取时间，不断回调自己。如果数据量太大，其实是不建议这么干的。后面我做了一个小数据量（即10000）的情况下，内存基本没什么影响，使用不同的数据，计算了100次，算出其效率比希尔排序还要快10倍，比冒泡排序快4698倍，数据量越大，其占内存越大，同时，其与其他排序方式的速度差距也越大。123456789101112131415161718192021//快速排序function quickSort(arr) &#123; var len = arr.length; if(len == 0)&#123; return []; &#125; else if(len == 1)&#123; return arr; &#125; var smallArr = []; var largeArr = []; var pivot = arr[0]; for (var i = 1; i &lt; len; i++) &#123; if (arr[i] &lt; pivot) &#123; smallArr.push(arr[i]); &#125; else &#123; largeArr.push(arr[i]); &#125; &#125; return quickSort(smallArr).concat(pivot, quickSort(largeArr));&#125; 以上算法的demo : http://www.boatsky.com/static/js/demo/sort_demo.js 这里写一个简单的程序，对上述算法时间计算，各个数组10000个数字，计算100次，取平均值，此处以快速排序为例 1234567891011121314151617181920212223242526272829303132333435363738//分别是每次的计算的开始时间与结束时间var d1,d2;//保存每次计算的时候var arrTime = [];//随机生成数组元素//以为是计算时间例子//分别是每次的计算的开始时间与结束时间var d1,d2;//保存每次计算的时候var arrTime = [];//随机生成数组元素function getArr()&#123; var arr = []; for(var i = 0;i &lt; 10000;i++)&#123; arr.push(Math.floor(Math.random()*10000)); &#125; return arr;&#125;//快速排序//获取时间function getTime()&#123; //计算100次，取平均值，减小误差 for(var k = 0;k &lt; 100;k++)&#123; var arr = getArr(); d1 = new Date().getTime(); arr = quickSort(arr); d2 = new Date().getTime(); arrTime.push(d2-d1); &#125; var all = 0; for(var m = 0;m &lt; arrTime.length;m++)&#123; all = all + arrTime[m]; &#125; console.log(arrTime); console.log(all/arrTime.length);&#125;getTime(); 统计100次 平均时间(ms) 时间复杂度 空间复杂度 稳定性冒泡排序 704.69 O(n(n+1)/2) O(1) 稳定选择排序 214.31 O(n(n+1)/2) O(1) 稳定插入排序 50.62 O(n)~O(n^2/2) O(1) 不稳定归并排序 2.16 O(n log n) O(n) 稳定希尔排序 1.5 O(n log n) ~ O(n^2) O(1) 不稳定快速排序 0.15 O(n log 2 n) ~ O(n^2) O(log 2 n) ~ O(n) 不稳定 所以说，上述6种常见算法中，快速排序是最快的，但如果数据量太大时，内存占用大，而希尔排序速度较快，占内存小，稳定性略差。多数情况下都推荐这两种。 所以，根据你数据的类型，数据量的大小，机器内存的大小，进行一定的测试，选择最适合你的排序吧。 所以说，不要在任何情况下都用冒泡排序啦！！！","tags":[]},{"title":"使用webpack构建时给window绑定事件的坑","date":"2017-03-28T07:45:25.000Z","path":"2017/03/28/使用webpack构建时给window绑定事件的坑/","text":"使用webpack进行构建，给window绑定了onload的事件，结果竟然死活不触发！各种排除后发现问题所在… 业务js文件index.js 12345678var $ = require('jquery');$(function()&#123; // 在这里绑定，无效 $(window).on('load', function()&#123; console.log('页面加载完成了~'); &#125;);&#125;) 打开页面，然后控制台并没有打印出“页面加载完成了~” 难道是使用jquery进行绑定的原因导致事件绑定无效？于是改了代码： 12345678var $ = require('jquery');$(function()&#123; // 在这里绑定，还是无效 window.onload = function()&#123; console.log('页面加载完成了~'); &#125;;&#125;) 控制台依然没有打印出预期的结果，苦思良久，改成 123456789101112131415var $ = require('jquery');// 在这里绑定，有效$(window).on('load', function()&#123; console.log('页面加载完成了~ 1');&#125;);// 在这里绑定，也有效window.onload = function()&#123; console.log('页面加载完成了~ 2');&#125;;$(function()&#123; &#125;) 那看来是’$(function(){})’这一段代码的问题了，这段代码并不难理解，当页面的dom结构加载完毕则执行，刚入门是使用’script’标签引入jquery，并没有这样的问题出现。 那么现在看来是使用webpack进行构建的并发症了，至于原因，并没有深究的意愿。 现在页面的js基本都是放在页面底部，程序执行到这里，其实意味着dom结构以及渲染完毕了，个人觉得在js中写’$(function(){})’是没有必要了的","tags":[{"name":"webpack","slug":"webpack","permalink":"http://yoursite.com/tags/webpack/"},{"name":"jquery","slug":"jquery","permalink":"http://yoursite.com/tags/jquery/"}]},{"title":"使用hexo遇到的一个坑","date":"2017-03-23T03:46:16.000Z","path":"2017/03/23/使用hexo遇到的一个坑/","text":"hexo中首页列表的摘要（excerpt）弄不出来，一直显示全文 修改了N多配置都不生效，官方文档中也没有说明，唯有各种搜索答案，终于找到了！ 原来只需要在文中加入&lt;!-- more --&gt;就可以了，这实在是个大坑！ 12345这就是一个简介&lt;!-- more --&gt; 这里更多的内容 原答案链接","tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"}]},{"title":"Express路由","date":"2017-03-22T08:11:33.000Z","path":"2017/03/22/express路由/","text":"一、简介 1、Express 是一个基于 Node.js 平台的极简、灵活的web应用开发框架，它提供一系列强大的特性，帮助你创建各种 Web 和移动设备应用。 2、丰富的 HTTP 快捷方法和任意排列组合的 Connect 中间件，让你创建健壮、友好的 API 变得既快速又简单。 （ Express 是一个自身功能极简，完全是由路由和中间件构成一个的 web 开发框架） 3、Express 不对 Node.js 已有的特性进行二次抽象，我们只是在它之上扩展了 Web 应用所需的基本功能。 &nbsp; 二、express环境搭建1、安装nodejs和npm，建议安装淘宝提供的国内镜像cnpm，这样安装比较快 1$ npm install –g cnpm 2、新建一个目录，在目录下执行 1$ cnpm install express --save 3、express环境已经搭建好了 &nbsp; 三、基本路由1、简单版，除了get请求，还有post、put、delete 123456789101112131415161718192021222324252627282930313233343536373839404142var express = require('express');var app = express();app.get('/', function (req, res) &#123; res.send('Hello World! &lt;a href=\"/news\"&gt;to news&lt;/a&gt;');&#125;);app.get('/news', function (req, res) &#123; res.send('this is news. &lt;a href=\"/\"&gt;back&lt;/a&gt;');&#125;).post('/news', function (req, res) &#123; console.log('query：' + req.query); console.log('body：' + req.body); res.send(&#123; code: 'abc123', msg: 'get a post request!', data: req.query &#125;);&#125;).put('/news', function (req, res) &#123; console.log('query：' + req.query); console.log('body：' + req.body); res.send(&#123; code: 'abc123', msg: 'get a put request!', data: req.query &#125;);&#125;).delete('/news', function (req, res) &#123; console.log('query：' + req.query); console.log('body：' + req.body); res.send(&#123; code: 'abc123', msg: 'get a delete request!', data: req.query &#125;);&#125;);var server = app.listen(12345, function () &#123; var host = server.address().address; var port = server.address().port; console.log('Example app listening at http://%s:%s', host, port);&#125;); 2、字符匹配模式 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465var express = require('express');var app = express();// 路径var _routeStr = ['start'];var _routeList = ['&lt;ol&gt;'];_routeList.push('&lt;li&gt;ab?cd（匹配 acd 和 abcd）&lt;/li&gt;');_routeList.push('&lt;li&gt;ab+cd（匹配 abcd、abbcd、abbbcd等）&lt;/li&gt;');_routeList.push('&lt;li&gt;ab*cd（匹配 abcd、abxcd、abRABDOMcd、ab123cd等）&lt;/li&gt;');_routeList.push('&lt;li&gt;ab(cd)?e（匹配 /abe 和 /abcde）&lt;/li&gt;');_routeList.push('&lt;/ol&gt;');app.all('*', function (req, res, next) &#123; console.log('Accessing：' + new Date()); _routeStr = ['start']; next();&#125;);// 匹配 acd 和 abcdapp.get('/ab?cd', function(req, res, next) &#123; // res.send('ab?cd'); _routeStr.push('ab?cd'); next();&#125;);// 匹配 abcd、abbcd、abbbcd等app.get('/ab+cd', function(req, res, next) &#123; // res.send('ab+cd'); _routeStr.push('ab+cd'); next();&#125;);// 匹配 abcd、abxcd、abRABDOMcd、ab123cd等app.get('/ab*cd', function(req, res, next) &#123; // res.send('ab*cd'); _routeStr.push('ab*cd'); next();&#125;);// 匹配 /abe 和 /abcdeapp.get('/ab(cd)?e', function(req, res, next) &#123; // res.send('ab(cd)?e'); _routeStr.push('ab(cd)?e'); next();&#125;);app.get('*', function(req, res) &#123; _routeStr.push('end'); var _html = '&lt;p&gt;' + _routeStr.join(' ====&gt; ') + '&lt;/p&gt;'; res.send(_routeList.join('') + _html);&#125;);var server = app.listen(12345, function () &#123; var host = server.address().address; var port = server.address().port; console.log('Example app listening at http://%s:%s', host, port);&#125;); 3、正则匹配模式 12345678910111213141516171819202122232425262728293031323334353637383940414243444546var express = require('express');var app = express();// 路径var _routeStr = ['start'];var _routeList = ['&lt;ol&gt;'];_routeList.push('&lt;li&gt;/a/（匹配任何路径中含有 a 的路径');_routeList.push('&lt;li&gt;/.*fly$/（匹配 butterfly、dragonfly，不匹配 butterflyman、dragonfly man等）&lt;/li&gt;');_routeList.push('&lt;/ol&gt;');app.all('*', function (req, res, next) &#123; console.log('Accessing：' + new Date()); _routeStr = ['start']; next();&#125;);// 匹配任何路径中含有 a 的路径：app.get(/a/, function(req, res, next) &#123; _routeStr.push('/a/'); next();&#125;);// 匹配 butterfly、dragonfly，不匹配 butterflyman、dragonfly man等app.get(/.*fly$/, function(req, res, next) &#123; _routeStr.push('/.*fly$/'); next();&#125;);app.get('*', function(req, res) &#123; _routeStr.push('end'); var _html = '&lt;p&gt;' + _routeStr.join(' ====&gt; ') + '&lt;/p&gt;'; res.send(_routeList.join('') + _html);&#125;);var server = app.listen(12345, function () &#123; var host = server.address().address; var port = server.address().port; console.log('Example app listening at http://%s:%s', host, port);&#125;); 3、执行多个回调 1234567891011121314151617181920212223242526272829303132333435363738var express = require('express');var app = express();// 多个回调函数，需指定执行nextapp.get('/b', function (req, res, next) &#123; console.log('this is function b one'); next();&#125;, function (req, res) &#123; console.log('this is function b two'); res.send('Hello from B!');&#125;);// 多个回调传入，需指定执行next，最后必须有sendvar cb0 = function (req, res, next) &#123; console.log('CB0'); next();&#125;var cb1 = function (req, res, next) &#123; console.log('CB1'); next();&#125;var cb2 = function (req, res) &#123; res.send('Hello from C!');&#125;app.get('/c', [cb0, cb1, cb2]);var server = app.listen(12345, function () &#123; var host = server.address().address; var port = server.address().port; console.log('Example app listening at http://%s:%s', host, port);&#125;); &nbsp; 四、中间件router1、通过require导入各种路由配置文件 12345678910111213141516171819202122var express = require('express');var app = express();var _router1 = require('./router/r1.js');var _router2 = require('./router/r2.js');var _router3 = require('./router/r3.js');var _router4 = require('./router/r4.js');app.use('/', _router1);app.use('/r2', _router2);app.use('/r3', _router3);app.use('/r4', _router4);var server = app.listen(12345, function () &#123; var host = server.address().address; var port = server.address().port; console.log('Example app listening at http://%s:%s', host, port);&#125;); 2、简单版 1234567891011121314151617181920var express = require('express');var router = express.Router();// 该路由使用的中间件router.use(function (req, res, next) &#123; console.log('Time:', Date.now()); next();&#125;);// 定义网站主页的路由router.get('/', function(req, res) &#123; res.send('Birds home page');&#125;);// 定义 about 页面的路由router.get('/about', function(req, res) &#123; res.send('About birds');&#125;);module.exports = router; 3、通过路由中间件控制 1234567891011121314151617181920212223242526272829303132333435363738var express = require('express');var router = express.Router();// 该路由使用的中间件router.use(function (req, res, next) &#123; console.log('Time:', Date.now()); next();&#125;);// 一个中间件栈，显示任何指向 /user/:id 的 HTTP 请求的信息router.use('/user/:id', function(req, res, next) &#123; console.log('Request URL:', req.originalUrl); next();&#125;, function (req, res, next) &#123; console.log('Request Type:', req.method); next();&#125;);// 一个中间件栈，处理指向 /user/:id 的 GET 请求router.get('/user/:id', function (req, res, next) &#123; console.log(req.params, req.params.id == 0); // 如果 user id 为 0, 跳到下一个路由 if (req.params.id == 0)&#123; res.send('ID：' + req.params.id); &#125; // 负责将控制权交给栈中下一个中间件 else&#123; next(); &#125;&#125;, function (req, res, next) &#123; // 渲染常规页面 res.send('next function ID：' + req.params.id); // 填到下一个路由 // next();&#125;);module.exports = router; 使用router.param 123456789101112131415161718192021222324252627282930var express = require('express');var router = express.Router();// 该路由使用的中间件router.use(function (req, res, next) &#123; console.log('Time:', Date.now()); next();&#125;);var _pid;router.get('/blog/:pid', function (req, res, next) &#123; console.log('get function');&#125;);router.param('pid', function (req, res, next, pid)&#123; console.log('param function'); // console.log(req.query); setTimeout(function()&#123; _pid = pid; res.send('my pid is：' + pid + '&amp;&amp;' + req.query.id); &#125;, 1000); next();&#125;);module.exports = router; 多个参数的情况下 12345678910111213141516171819202122232425262728293031323334353637var express = require('express');var router = express.Router();// 该路由使用的中间件router.use(function (req, res, next) &#123; console.log('Time:', Date.now()); next();&#125;);// 无效，可能是版本问题// router.param(['id', 'page'], function (req, res, next, value) &#123;// console.log('CALLED ONLY ONCE with', value);// next();// &#125;)router.param('nid', function (req, res, next, value) &#123; console.log('nid：', value); next();&#125;);router.param('page', function (req, res, next, value) &#123; console.log('page：', value); next();&#125;);router.get('/news/:nid/:page', function (req, res, next) &#123; console.log('although this matches'); next();&#125;);router.get('/news/:nid/:page', function (req, res) &#123; console.log('and this matches too'); res.send('ok');&#125;);module.exports = router; &nbsp; 五、静态资源目录也算是属于路由中的一部分，负责静态资源的路径设置 1234567891011121314151617181920212223242526var express = require('express');var app = express();app.use(express.static(__dirname + '/images'));app.use('/pic', express.static(__dirname + '/images'));app.use('/img', express.static(__dirname + '/images'));app.get('/img', function (req, res) &#123; var _html = ''; _html += '&lt;p&gt;/icon.png&lt;/p&gt;&lt;img src=\"/icon.png\" /&gt;'; _html += '&lt;p&gt;/pic/icon.png&lt;/p&gt;&lt;img src=\"/pic/icon.png\" /&gt;'; _html += '&lt;p&gt;/img/icon.png&lt;/p&gt;&lt;img src=\"/img/icon.png\" /&gt;'; res.send(_html);&#125;);var server = app.listen(12345, function () &#123; var host = server.address().address; var port = server.address().port; console.log('Example app listening at http://%s:%s', host, port);&#125;); &nbsp; 六、实例源码github express_demo","tags":[{"name":"nodejs","slug":"nodejs","permalink":"http://yoursite.com/tags/nodejs/"},{"name":"express","slug":"express","permalink":"http://yoursite.com/tags/express/"},{"name":"router","slug":"router","permalink":"http://yoursite.com/tags/router/"}]}]